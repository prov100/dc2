// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: tax/v1/tax.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on GetTaxSchemesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTaxSchemesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTaxSchemesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTaxSchemesResponseMultiError, or nil if none found.
func (m *GetTaxSchemesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTaxSchemesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTaxSchemes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetTaxSchemesResponseValidationError{
						field:  fmt.Sprintf("TaxSchemes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetTaxSchemesResponseValidationError{
						field:  fmt.Sprintf("TaxSchemes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetTaxSchemesResponseValidationError{
					field:  fmt.Sprintf("TaxSchemes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextCursor

	if len(errors) > 0 {
		return GetTaxSchemesResponseMultiError(errors)
	}

	return nil
}

// GetTaxSchemesResponseMultiError is an error wrapping multiple validation
// errors returned by GetTaxSchemesResponse.ValidateAll() if the designated
// constraints aren't met.
type GetTaxSchemesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTaxSchemesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTaxSchemesResponseMultiError) AllErrors() []error { return m }

// GetTaxSchemesResponseValidationError is the validation error returned by
// GetTaxSchemesResponse.Validate if the designated constraints aren't met.
type GetTaxSchemesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTaxSchemesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTaxSchemesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTaxSchemesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTaxSchemesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTaxSchemesResponseValidationError) ErrorName() string {
	return "GetTaxSchemesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetTaxSchemesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTaxSchemesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTaxSchemesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTaxSchemesResponseValidationError{}

// Validate checks the field values on GetTaxSchemesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTaxSchemesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTaxSchemesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTaxSchemesRequestMultiError, or nil if none found.
func (m *GetTaxSchemesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTaxSchemesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Limit

	// no validation rules for NextCursor

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return GetTaxSchemesRequestMultiError(errors)
	}

	return nil
}

// GetTaxSchemesRequestMultiError is an error wrapping multiple validation
// errors returned by GetTaxSchemesRequest.ValidateAll() if the designated
// constraints aren't met.
type GetTaxSchemesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTaxSchemesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTaxSchemesRequestMultiError) AllErrors() []error { return m }

// GetTaxSchemesRequestValidationError is the validation error returned by
// GetTaxSchemesRequest.Validate if the designated constraints aren't met.
type GetTaxSchemesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTaxSchemesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTaxSchemesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTaxSchemesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTaxSchemesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTaxSchemesRequestValidationError) ErrorName() string {
	return "GetTaxSchemesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTaxSchemesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTaxSchemesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTaxSchemesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTaxSchemesRequestValidationError{}

// Validate checks the field values on GetTaxSchemeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTaxSchemeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTaxSchemeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTaxSchemeRequestMultiError, or nil if none found.
func (m *GetTaxSchemeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTaxSchemeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGetRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTaxSchemeRequestValidationError{
					field:  "GetRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTaxSchemeRequestValidationError{
					field:  "GetRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGetRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTaxSchemeRequestValidationError{
				field:  "GetRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTaxSchemeRequestMultiError(errors)
	}

	return nil
}

// GetTaxSchemeRequestMultiError is an error wrapping multiple validation
// errors returned by GetTaxSchemeRequest.ValidateAll() if the designated
// constraints aren't met.
type GetTaxSchemeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTaxSchemeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTaxSchemeRequestMultiError) AllErrors() []error { return m }

// GetTaxSchemeRequestValidationError is the validation error returned by
// GetTaxSchemeRequest.Validate if the designated constraints aren't met.
type GetTaxSchemeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTaxSchemeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTaxSchemeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTaxSchemeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTaxSchemeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTaxSchemeRequestValidationError) ErrorName() string {
	return "GetTaxSchemeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTaxSchemeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTaxSchemeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTaxSchemeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTaxSchemeRequestValidationError{}

// Validate checks the field values on GetTaxSchemeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTaxSchemeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTaxSchemeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTaxSchemeResponseMultiError, or nil if none found.
func (m *GetTaxSchemeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTaxSchemeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTaxScheme()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTaxSchemeResponseValidationError{
					field:  "TaxScheme",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTaxSchemeResponseValidationError{
					field:  "TaxScheme",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTaxScheme()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTaxSchemeResponseValidationError{
				field:  "TaxScheme",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTaxSchemeResponseMultiError(errors)
	}

	return nil
}

// GetTaxSchemeResponseMultiError is an error wrapping multiple validation
// errors returned by GetTaxSchemeResponse.ValidateAll() if the designated
// constraints aren't met.
type GetTaxSchemeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTaxSchemeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTaxSchemeResponseMultiError) AllErrors() []error { return m }

// GetTaxSchemeResponseValidationError is the validation error returned by
// GetTaxSchemeResponse.Validate if the designated constraints aren't met.
type GetTaxSchemeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTaxSchemeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTaxSchemeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTaxSchemeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTaxSchemeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTaxSchemeResponseValidationError) ErrorName() string {
	return "GetTaxSchemeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetTaxSchemeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTaxSchemeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTaxSchemeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTaxSchemeResponseValidationError{}

// Validate checks the field values on TaxCategory with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TaxCategory) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaxCategory with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TaxCategoryMultiError, or
// nil if none found.
func (m *TaxCategory) ValidateAll() error {
	return m.validate(true)
}

func (m *TaxCategory) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTaxCategoryD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaxCategoryValidationError{
					field:  "TaxCategoryD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaxCategoryValidationError{
					field:  "TaxCategoryD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTaxCategoryD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaxCategoryValidationError{
				field:  "TaxCategoryD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaxCategoryValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaxCategoryValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaxCategoryValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaxCategoryValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaxCategoryValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaxCategoryValidationError{
				field:  "CrUpdTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TaxCategoryMultiError(errors)
	}

	return nil
}

// TaxCategoryMultiError is an error wrapping multiple validation errors
// returned by TaxCategory.ValidateAll() if the designated constraints aren't met.
type TaxCategoryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaxCategoryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaxCategoryMultiError) AllErrors() []error { return m }

// TaxCategoryValidationError is the validation error returned by
// TaxCategory.Validate if the designated constraints aren't met.
type TaxCategoryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaxCategoryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaxCategoryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaxCategoryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaxCategoryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaxCategoryValidationError) ErrorName() string { return "TaxCategoryValidationError" }

// Error satisfies the builtin error interface
func (e TaxCategoryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaxCategory.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaxCategoryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaxCategoryValidationError{}

// Validate checks the field values on TaxCategoryD with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TaxCategoryD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaxCategoryD with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TaxCategoryDMultiError, or
// nil if none found.
func (m *TaxCategoryD) ValidateAll() error {
	return m.validate(true)
}

func (m *TaxCategoryD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for TcId

	// no validation rules for TaxCategoryName

	// no validation rules for Percent

	// no validation rules for BaseUnitMeasure

	// no validation rules for PerUnitAmount

	// no validation rules for TaxExemptionReasonCode

	// no validation rules for TaxExemptionReason

	// no validation rules for TierRange

	// no validation rules for TierRatePercent

	// no validation rules for TaxSchemeId

	if len(errors) > 0 {
		return TaxCategoryDMultiError(errors)
	}

	return nil
}

// TaxCategoryDMultiError is an error wrapping multiple validation errors
// returned by TaxCategoryD.ValidateAll() if the designated constraints aren't met.
type TaxCategoryDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaxCategoryDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaxCategoryDMultiError) AllErrors() []error { return m }

// TaxCategoryDValidationError is the validation error returned by
// TaxCategoryD.Validate if the designated constraints aren't met.
type TaxCategoryDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaxCategoryDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaxCategoryDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaxCategoryDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaxCategoryDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaxCategoryDValidationError) ErrorName() string { return "TaxCategoryDValidationError" }

// Error satisfies the builtin error interface
func (e TaxCategoryDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaxCategoryD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaxCategoryDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaxCategoryDValidationError{}

// Validate checks the field values on CreateTaxCategoryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTaxCategoryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTaxCategoryRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTaxCategoryRequestMultiError, or nil if none found.
func (m *CreateTaxCategoryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTaxCategoryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TcId

	// no validation rules for TaxCategoryName

	// no validation rules for Percent

	// no validation rules for BaseUnitMeasure

	// no validation rules for PerUnitAmount

	// no validation rules for TaxExemptionReasonCode

	// no validation rules for TaxExemptionReason

	// no validation rules for TierRange

	// no validation rules for TierRatePercent

	// no validation rules for TaxSchemeId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateTaxCategoryRequestMultiError(errors)
	}

	return nil
}

// CreateTaxCategoryRequestMultiError is an error wrapping multiple validation
// errors returned by CreateTaxCategoryRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateTaxCategoryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTaxCategoryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTaxCategoryRequestMultiError) AllErrors() []error { return m }

// CreateTaxCategoryRequestValidationError is the validation error returned by
// CreateTaxCategoryRequest.Validate if the designated constraints aren't met.
type CreateTaxCategoryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTaxCategoryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTaxCategoryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTaxCategoryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTaxCategoryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTaxCategoryRequestValidationError) ErrorName() string {
	return "CreateTaxCategoryRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTaxCategoryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTaxCategoryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTaxCategoryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTaxCategoryRequestValidationError{}

// Validate checks the field values on CreateTaxCategoryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTaxCategoryResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTaxCategoryResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTaxCategoryResponseMultiError, or nil if none found.
func (m *CreateTaxCategoryResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTaxCategoryResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTaxCategory()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTaxCategoryResponseValidationError{
					field:  "TaxCategory",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTaxCategoryResponseValidationError{
					field:  "TaxCategory",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTaxCategory()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTaxCategoryResponseValidationError{
				field:  "TaxCategory",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTaxCategoryResponseMultiError(errors)
	}

	return nil
}

// CreateTaxCategoryResponseMultiError is an error wrapping multiple validation
// errors returned by CreateTaxCategoryResponse.ValidateAll() if the
// designated constraints aren't met.
type CreateTaxCategoryResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTaxCategoryResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTaxCategoryResponseMultiError) AllErrors() []error { return m }

// CreateTaxCategoryResponseValidationError is the validation error returned by
// CreateTaxCategoryResponse.Validate if the designated constraints aren't met.
type CreateTaxCategoryResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTaxCategoryResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTaxCategoryResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTaxCategoryResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTaxCategoryResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTaxCategoryResponseValidationError) ErrorName() string {
	return "CreateTaxCategoryResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTaxCategoryResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTaxCategoryResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTaxCategoryResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTaxCategoryResponseValidationError{}

// Validate checks the field values on UpdateTaxCategoryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateTaxCategoryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateTaxCategoryRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateTaxCategoryRequestMultiError, or nil if none found.
func (m *UpdateTaxCategoryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateTaxCategoryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TaxCategoryName

	// no validation rules for Percent

	// no validation rules for BaseUnitMeasure

	// no validation rules for PerUnitAmount

	// no validation rules for TaxExemptionReasonCode

	// no validation rules for TaxExemptionReason

	// no validation rules for Id

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return UpdateTaxCategoryRequestMultiError(errors)
	}

	return nil
}

// UpdateTaxCategoryRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateTaxCategoryRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateTaxCategoryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateTaxCategoryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateTaxCategoryRequestMultiError) AllErrors() []error { return m }

// UpdateTaxCategoryRequestValidationError is the validation error returned by
// UpdateTaxCategoryRequest.Validate if the designated constraints aren't met.
type UpdateTaxCategoryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTaxCategoryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTaxCategoryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTaxCategoryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTaxCategoryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTaxCategoryRequestValidationError) ErrorName() string {
	return "UpdateTaxCategoryRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTaxCategoryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTaxCategoryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTaxCategoryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTaxCategoryRequestValidationError{}

// Validate checks the field values on UpdateTaxCategoryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateTaxCategoryResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateTaxCategoryResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateTaxCategoryResponseMultiError, or nil if none found.
func (m *UpdateTaxCategoryResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateTaxCategoryResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateTaxCategoryResponseMultiError(errors)
	}

	return nil
}

// UpdateTaxCategoryResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateTaxCategoryResponse.ValidateAll() if the
// designated constraints aren't met.
type UpdateTaxCategoryResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateTaxCategoryResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateTaxCategoryResponseMultiError) AllErrors() []error { return m }

// UpdateTaxCategoryResponseValidationError is the validation error returned by
// UpdateTaxCategoryResponse.Validate if the designated constraints aren't met.
type UpdateTaxCategoryResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTaxCategoryResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTaxCategoryResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTaxCategoryResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTaxCategoryResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTaxCategoryResponseValidationError) ErrorName() string {
	return "UpdateTaxCategoryResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTaxCategoryResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTaxCategoryResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTaxCategoryResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTaxCategoryResponseValidationError{}

// Validate checks the field values on TaxScheme with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TaxScheme) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaxScheme with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TaxSchemeMultiError, or nil
// if none found.
func (m *TaxScheme) ValidateAll() error {
	return m.validate(true)
}

func (m *TaxScheme) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTaxSchemeD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaxSchemeValidationError{
					field:  "TaxSchemeD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaxSchemeValidationError{
					field:  "TaxSchemeD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTaxSchemeD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaxSchemeValidationError{
				field:  "TaxSchemeD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaxSchemeValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaxSchemeValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaxSchemeValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaxSchemeValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaxSchemeValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaxSchemeValidationError{
				field:  "CrUpdTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TaxSchemeMultiError(errors)
	}

	return nil
}

// TaxSchemeMultiError is an error wrapping multiple validation errors returned
// by TaxScheme.ValidateAll() if the designated constraints aren't met.
type TaxSchemeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaxSchemeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaxSchemeMultiError) AllErrors() []error { return m }

// TaxSchemeValidationError is the validation error returned by
// TaxScheme.Validate if the designated constraints aren't met.
type TaxSchemeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaxSchemeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaxSchemeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaxSchemeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaxSchemeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaxSchemeValidationError) ErrorName() string { return "TaxSchemeValidationError" }

// Error satisfies the builtin error interface
func (e TaxSchemeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaxScheme.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaxSchemeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaxSchemeValidationError{}

// Validate checks the field values on TaxSchemeD with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TaxSchemeD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaxSchemeD with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TaxSchemeDMultiError, or
// nil if none found.
func (m *TaxSchemeD) ValidateAll() error {
	return m.validate(true)
}

func (m *TaxSchemeD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for TsId

	// no validation rules for TaxSchemeName

	// no validation rules for TaxTypeCode

	// no validation rules for CurrencyCode

	if len(errors) > 0 {
		return TaxSchemeDMultiError(errors)
	}

	return nil
}

// TaxSchemeDMultiError is an error wrapping multiple validation errors
// returned by TaxSchemeD.ValidateAll() if the designated constraints aren't met.
type TaxSchemeDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaxSchemeDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaxSchemeDMultiError) AllErrors() []error { return m }

// TaxSchemeDValidationError is the validation error returned by
// TaxSchemeD.Validate if the designated constraints aren't met.
type TaxSchemeDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaxSchemeDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaxSchemeDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaxSchemeDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaxSchemeDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaxSchemeDValidationError) ErrorName() string { return "TaxSchemeDValidationError" }

// Error satisfies the builtin error interface
func (e TaxSchemeDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaxSchemeD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaxSchemeDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaxSchemeDValidationError{}

// Validate checks the field values on CreateTaxSchemeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTaxSchemeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTaxSchemeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTaxSchemeRequestMultiError, or nil if none found.
func (m *CreateTaxSchemeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTaxSchemeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TsId

	// no validation rules for TaxSchemeName

	// no validation rules for TaxTypeCode

	// no validation rules for CurrencyCode

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateTaxSchemeRequestMultiError(errors)
	}

	return nil
}

// CreateTaxSchemeRequestMultiError is an error wrapping multiple validation
// errors returned by CreateTaxSchemeRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateTaxSchemeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTaxSchemeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTaxSchemeRequestMultiError) AllErrors() []error { return m }

// CreateTaxSchemeRequestValidationError is the validation error returned by
// CreateTaxSchemeRequest.Validate if the designated constraints aren't met.
type CreateTaxSchemeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTaxSchemeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTaxSchemeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTaxSchemeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTaxSchemeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTaxSchemeRequestValidationError) ErrorName() string {
	return "CreateTaxSchemeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTaxSchemeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTaxSchemeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTaxSchemeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTaxSchemeRequestValidationError{}

// Validate checks the field values on UpdateTaxSchemeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateTaxSchemeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateTaxSchemeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateTaxSchemeRequestMultiError, or nil if none found.
func (m *UpdateTaxSchemeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateTaxSchemeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TaxSchemeName

	// no validation rules for TaxTypeCode

	// no validation rules for CurrencyCode

	// no validation rules for Id

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return UpdateTaxSchemeRequestMultiError(errors)
	}

	return nil
}

// UpdateTaxSchemeRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateTaxSchemeRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateTaxSchemeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateTaxSchemeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateTaxSchemeRequestMultiError) AllErrors() []error { return m }

// UpdateTaxSchemeRequestValidationError is the validation error returned by
// UpdateTaxSchemeRequest.Validate if the designated constraints aren't met.
type UpdateTaxSchemeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTaxSchemeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTaxSchemeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTaxSchemeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTaxSchemeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTaxSchemeRequestValidationError) ErrorName() string {
	return "UpdateTaxSchemeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTaxSchemeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTaxSchemeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTaxSchemeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTaxSchemeRequestValidationError{}

// Validate checks the field values on UpdateTaxSchemeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateTaxSchemeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateTaxSchemeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateTaxSchemeResponseMultiError, or nil if none found.
func (m *UpdateTaxSchemeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateTaxSchemeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateTaxSchemeResponseMultiError(errors)
	}

	return nil
}

// UpdateTaxSchemeResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateTaxSchemeResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateTaxSchemeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateTaxSchemeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateTaxSchemeResponseMultiError) AllErrors() []error { return m }

// UpdateTaxSchemeResponseValidationError is the validation error returned by
// UpdateTaxSchemeResponse.Validate if the designated constraints aren't met.
type UpdateTaxSchemeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTaxSchemeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTaxSchemeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTaxSchemeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTaxSchemeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTaxSchemeResponseValidationError) ErrorName() string {
	return "UpdateTaxSchemeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTaxSchemeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTaxSchemeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTaxSchemeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTaxSchemeResponseValidationError{}

// Validate checks the field values on CreateTaxSchemeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTaxSchemeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTaxSchemeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTaxSchemeResponseMultiError, or nil if none found.
func (m *CreateTaxSchemeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTaxSchemeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTaxScheme()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTaxSchemeResponseValidationError{
					field:  "TaxScheme",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTaxSchemeResponseValidationError{
					field:  "TaxScheme",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTaxScheme()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTaxSchemeResponseValidationError{
				field:  "TaxScheme",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTaxSchemeResponseMultiError(errors)
	}

	return nil
}

// CreateTaxSchemeResponseMultiError is an error wrapping multiple validation
// errors returned by CreateTaxSchemeResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateTaxSchemeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTaxSchemeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTaxSchemeResponseMultiError) AllErrors() []error { return m }

// CreateTaxSchemeResponseValidationError is the validation error returned by
// CreateTaxSchemeResponse.Validate if the designated constraints aren't met.
type CreateTaxSchemeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTaxSchemeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTaxSchemeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTaxSchemeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTaxSchemeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTaxSchemeResponseValidationError) ErrorName() string {
	return "CreateTaxSchemeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTaxSchemeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTaxSchemeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTaxSchemeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTaxSchemeResponseValidationError{}

// Validate checks the field values on TaxSchemeJurisdiction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TaxSchemeJurisdiction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaxSchemeJurisdiction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TaxSchemeJurisdictionMultiError, or nil if none found.
func (m *TaxSchemeJurisdiction) ValidateAll() error {
	return m.validate(true)
}

func (m *TaxSchemeJurisdiction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTaxSchemeJurisdictionD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaxSchemeJurisdictionValidationError{
					field:  "TaxSchemeJurisdictionD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaxSchemeJurisdictionValidationError{
					field:  "TaxSchemeJurisdictionD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTaxSchemeJurisdictionD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaxSchemeJurisdictionValidationError{
				field:  "TaxSchemeJurisdictionD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTaxSchemeInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaxSchemeJurisdictionValidationError{
					field:  "TaxSchemeInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaxSchemeJurisdictionValidationError{
					field:  "TaxSchemeInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTaxSchemeInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaxSchemeJurisdictionValidationError{
				field:  "TaxSchemeInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaxSchemeJurisdictionValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaxSchemeJurisdictionValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaxSchemeJurisdictionValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaxSchemeJurisdictionValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaxSchemeJurisdictionValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaxSchemeJurisdictionValidationError{
				field:  "CrUpdTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TaxSchemeJurisdictionMultiError(errors)
	}

	return nil
}

// TaxSchemeJurisdictionMultiError is an error wrapping multiple validation
// errors returned by TaxSchemeJurisdiction.ValidateAll() if the designated
// constraints aren't met.
type TaxSchemeJurisdictionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaxSchemeJurisdictionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaxSchemeJurisdictionMultiError) AllErrors() []error { return m }

// TaxSchemeJurisdictionValidationError is the validation error returned by
// TaxSchemeJurisdiction.Validate if the designated constraints aren't met.
type TaxSchemeJurisdictionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaxSchemeJurisdictionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaxSchemeJurisdictionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaxSchemeJurisdictionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaxSchemeJurisdictionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaxSchemeJurisdictionValidationError) ErrorName() string {
	return "TaxSchemeJurisdictionValidationError"
}

// Error satisfies the builtin error interface
func (e TaxSchemeJurisdictionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaxSchemeJurisdiction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaxSchemeJurisdictionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaxSchemeJurisdictionValidationError{}

// Validate checks the field values on TaxSchemeJurisdictionD with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TaxSchemeJurisdictionD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaxSchemeJurisdictionD with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TaxSchemeJurisdictionDMultiError, or nil if none found.
func (m *TaxSchemeJurisdictionD) ValidateAll() error {
	return m.validate(true)
}

func (m *TaxSchemeJurisdictionD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for AddressId

	if len(errors) > 0 {
		return TaxSchemeJurisdictionDMultiError(errors)
	}

	return nil
}

// TaxSchemeJurisdictionDMultiError is an error wrapping multiple validation
// errors returned by TaxSchemeJurisdictionD.ValidateAll() if the designated
// constraints aren't met.
type TaxSchemeJurisdictionDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaxSchemeJurisdictionDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaxSchemeJurisdictionDMultiError) AllErrors() []error { return m }

// TaxSchemeJurisdictionDValidationError is the validation error returned by
// TaxSchemeJurisdictionD.Validate if the designated constraints aren't met.
type TaxSchemeJurisdictionDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaxSchemeJurisdictionDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaxSchemeJurisdictionDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaxSchemeJurisdictionDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaxSchemeJurisdictionDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaxSchemeJurisdictionDValidationError) ErrorName() string {
	return "TaxSchemeJurisdictionDValidationError"
}

// Error satisfies the builtin error interface
func (e TaxSchemeJurisdictionDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaxSchemeJurisdictionD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaxSchemeJurisdictionDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaxSchemeJurisdictionDValidationError{}

// Validate checks the field values on CreateTaxSchemeJurisdictionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreateTaxSchemeJurisdictionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTaxSchemeJurisdictionRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateTaxSchemeJurisdictionRequestMultiError, or nil if none found.
func (m *CreateTaxSchemeJurisdictionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTaxSchemeJurisdictionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AddrListAgencyId

	// no validation rules for AddrListId

	// no validation rules for AddrListVersionId

	// no validation rules for AddressTypeCode

	// no validation rules for AddressFormatCode

	// no validation rules for Postbox

	// no validation rules for Floor

	// no validation rules for Room

	// no validation rules for StreetName

	// no validation rules for AdditionalStreetName

	// no validation rules for BlockName

	// no validation rules for BuildingName

	// no validation rules for BuildingNumber

	// no validation rules for InhouseMail

	// no validation rules for Department

	// no validation rules for MarkAttention

	// no validation rules for MarkCare

	// no validation rules for PlotIdentification

	// no validation rules for CitySubdivisionName

	// no validation rules for CityName

	// no validation rules for PostalZone

	// no validation rules for CountrySubentity

	// no validation rules for CountrySubentityCode

	// no validation rules for Region

	// no validation rules for District

	// no validation rules for TimezoneOffset

	// no validation rules for CountryIdCode

	// no validation rules for CountryName

	// no validation rules for LocationCoordLat

	// no validation rules for LocationCoordLon

	// no validation rules for Note

	// no validation rules for TaxSchemeId

	// no validation rules for TaxSchemeName

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateTaxSchemeJurisdictionRequestMultiError(errors)
	}

	return nil
}

// CreateTaxSchemeJurisdictionRequestMultiError is an error wrapping multiple
// validation errors returned by
// CreateTaxSchemeJurisdictionRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateTaxSchemeJurisdictionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTaxSchemeJurisdictionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTaxSchemeJurisdictionRequestMultiError) AllErrors() []error { return m }

// CreateTaxSchemeJurisdictionRequestValidationError is the validation error
// returned by CreateTaxSchemeJurisdictionRequest.Validate if the designated
// constraints aren't met.
type CreateTaxSchemeJurisdictionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTaxSchemeJurisdictionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTaxSchemeJurisdictionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTaxSchemeJurisdictionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTaxSchemeJurisdictionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTaxSchemeJurisdictionRequestValidationError) ErrorName() string {
	return "CreateTaxSchemeJurisdictionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTaxSchemeJurisdictionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTaxSchemeJurisdictionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTaxSchemeJurisdictionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTaxSchemeJurisdictionRequestValidationError{}

// Validate checks the field values on CreateTaxSchemeJurisdictionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreateTaxSchemeJurisdictionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTaxSchemeJurisdictionResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateTaxSchemeJurisdictionResponseMultiError, or nil if none found.
func (m *CreateTaxSchemeJurisdictionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTaxSchemeJurisdictionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTaxSchemeJurisdiction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTaxSchemeJurisdictionResponseValidationError{
					field:  "TaxSchemeJurisdiction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTaxSchemeJurisdictionResponseValidationError{
					field:  "TaxSchemeJurisdiction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTaxSchemeJurisdiction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTaxSchemeJurisdictionResponseValidationError{
				field:  "TaxSchemeJurisdiction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTaxSchemeJurisdictionResponseMultiError(errors)
	}

	return nil
}

// CreateTaxSchemeJurisdictionResponseMultiError is an error wrapping multiple
// validation errors returned by
// CreateTaxSchemeJurisdictionResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateTaxSchemeJurisdictionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTaxSchemeJurisdictionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTaxSchemeJurisdictionResponseMultiError) AllErrors() []error { return m }

// CreateTaxSchemeJurisdictionResponseValidationError is the validation error
// returned by CreateTaxSchemeJurisdictionResponse.Validate if the designated
// constraints aren't met.
type CreateTaxSchemeJurisdictionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTaxSchemeJurisdictionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTaxSchemeJurisdictionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTaxSchemeJurisdictionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTaxSchemeJurisdictionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTaxSchemeJurisdictionResponseValidationError) ErrorName() string {
	return "CreateTaxSchemeJurisdictionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTaxSchemeJurisdictionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTaxSchemeJurisdictionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTaxSchemeJurisdictionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTaxSchemeJurisdictionResponseValidationError{}

// Validate checks the field values on UpdateTaxSchemeJurisdictionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UpdateTaxSchemeJurisdictionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateTaxSchemeJurisdictionRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UpdateTaxSchemeJurisdictionRequestMultiError, or nil if none found.
func (m *UpdateTaxSchemeJurisdictionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateTaxSchemeJurisdictionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TaxSchemeId

	// no validation rules for TaxSchemeName

	// no validation rules for Id

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return UpdateTaxSchemeJurisdictionRequestMultiError(errors)
	}

	return nil
}

// UpdateTaxSchemeJurisdictionRequestMultiError is an error wrapping multiple
// validation errors returned by
// UpdateTaxSchemeJurisdictionRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateTaxSchemeJurisdictionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateTaxSchemeJurisdictionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateTaxSchemeJurisdictionRequestMultiError) AllErrors() []error { return m }

// UpdateTaxSchemeJurisdictionRequestValidationError is the validation error
// returned by UpdateTaxSchemeJurisdictionRequest.Validate if the designated
// constraints aren't met.
type UpdateTaxSchemeJurisdictionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTaxSchemeJurisdictionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTaxSchemeJurisdictionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTaxSchemeJurisdictionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTaxSchemeJurisdictionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTaxSchemeJurisdictionRequestValidationError) ErrorName() string {
	return "UpdateTaxSchemeJurisdictionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTaxSchemeJurisdictionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTaxSchemeJurisdictionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTaxSchemeJurisdictionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTaxSchemeJurisdictionRequestValidationError{}

// Validate checks the field values on UpdateTaxSchemeJurisdictionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UpdateTaxSchemeJurisdictionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateTaxSchemeJurisdictionResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UpdateTaxSchemeJurisdictionResponseMultiError, or nil if none found.
func (m *UpdateTaxSchemeJurisdictionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateTaxSchemeJurisdictionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateTaxSchemeJurisdictionResponseMultiError(errors)
	}

	return nil
}

// UpdateTaxSchemeJurisdictionResponseMultiError is an error wrapping multiple
// validation errors returned by
// UpdateTaxSchemeJurisdictionResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateTaxSchemeJurisdictionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateTaxSchemeJurisdictionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateTaxSchemeJurisdictionResponseMultiError) AllErrors() []error { return m }

// UpdateTaxSchemeJurisdictionResponseValidationError is the validation error
// returned by UpdateTaxSchemeJurisdictionResponse.Validate if the designated
// constraints aren't met.
type UpdateTaxSchemeJurisdictionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTaxSchemeJurisdictionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTaxSchemeJurisdictionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTaxSchemeJurisdictionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTaxSchemeJurisdictionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTaxSchemeJurisdictionResponseValidationError) ErrorName() string {
	return "UpdateTaxSchemeJurisdictionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTaxSchemeJurisdictionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTaxSchemeJurisdictionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTaxSchemeJurisdictionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTaxSchemeJurisdictionResponseValidationError{}

// Validate checks the field values on TaxSubTotal with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TaxSubTotal) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaxSubTotal with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TaxSubTotalMultiError, or
// nil if none found.
func (m *TaxSubTotal) ValidateAll() error {
	return m.validate(true)
}

func (m *TaxSubTotal) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTaxSubTotalD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaxSubTotalValidationError{
					field:  "TaxSubTotalD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaxSubTotalValidationError{
					field:  "TaxSubTotalD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTaxSubTotalD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaxSubTotalValidationError{
				field:  "TaxSubTotalD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaxSubTotalValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaxSubTotalValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaxSubTotalValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaxSubTotalValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaxSubTotalValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaxSubTotalValidationError{
				field:  "CrUpdTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TaxSubTotalMultiError(errors)
	}

	return nil
}

// TaxSubTotalMultiError is an error wrapping multiple validation errors
// returned by TaxSubTotal.ValidateAll() if the designated constraints aren't met.
type TaxSubTotalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaxSubTotalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaxSubTotalMultiError) AllErrors() []error { return m }

// TaxSubTotalValidationError is the validation error returned by
// TaxSubTotal.Validate if the designated constraints aren't met.
type TaxSubTotalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaxSubTotalValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaxSubTotalValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaxSubTotalValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaxSubTotalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaxSubTotalValidationError) ErrorName() string { return "TaxSubTotalValidationError" }

// Error satisfies the builtin error interface
func (e TaxSubTotalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaxSubTotal.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaxSubTotalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaxSubTotalValidationError{}

// Validate checks the field values on TaxSubTotalD with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TaxSubTotalD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaxSubTotalD with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TaxSubTotalDMultiError, or
// nil if none found.
func (m *TaxSubTotalD) ValidateAll() error {
	return m.validate(true)
}

func (m *TaxSubTotalD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for TaxableAmount

	// no validation rules for TaxAmount

	// no validation rules for CalculationSequenceNumeric

	// no validation rules for TransactionCurrencyTaxAmount

	// no validation rules for Percent

	// no validation rules for BaseUnitMeasure

	// no validation rules for PerUnitAmount

	// no validation rules for TierRange

	// no validation rules for TierRatePercent

	// no validation rules for TaxCategoryId

	// no validation rules for TaxTotalId

	if len(errors) > 0 {
		return TaxSubTotalDMultiError(errors)
	}

	return nil
}

// TaxSubTotalDMultiError is an error wrapping multiple validation errors
// returned by TaxSubTotalD.ValidateAll() if the designated constraints aren't met.
type TaxSubTotalDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaxSubTotalDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaxSubTotalDMultiError) AllErrors() []error { return m }

// TaxSubTotalDValidationError is the validation error returned by
// TaxSubTotalD.Validate if the designated constraints aren't met.
type TaxSubTotalDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaxSubTotalDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaxSubTotalDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaxSubTotalDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaxSubTotalDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaxSubTotalDValidationError) ErrorName() string { return "TaxSubTotalDValidationError" }

// Error satisfies the builtin error interface
func (e TaxSubTotalDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaxSubTotalD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaxSubTotalDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaxSubTotalDValidationError{}

// Validate checks the field values on CreateTaxSubTotalRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTaxSubTotalRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTaxSubTotalRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTaxSubTotalRequestMultiError, or nil if none found.
func (m *CreateTaxSubTotalRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTaxSubTotalRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TaxableAmount

	// no validation rules for TaxAmount

	// no validation rules for CalculationSequenceNumeric

	// no validation rules for TransactionCurrencyTaxAmount

	// no validation rules for Percent

	// no validation rules for BaseUnitMeasure

	// no validation rules for PerUnitAmount

	// no validation rules for TierRange

	// no validation rules for TierRatePercent

	// no validation rules for TaxCategoryId

	// no validation rules for TaxTotalId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateTaxSubTotalRequestMultiError(errors)
	}

	return nil
}

// CreateTaxSubTotalRequestMultiError is an error wrapping multiple validation
// errors returned by CreateTaxSubTotalRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateTaxSubTotalRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTaxSubTotalRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTaxSubTotalRequestMultiError) AllErrors() []error { return m }

// CreateTaxSubTotalRequestValidationError is the validation error returned by
// CreateTaxSubTotalRequest.Validate if the designated constraints aren't met.
type CreateTaxSubTotalRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTaxSubTotalRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTaxSubTotalRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTaxSubTotalRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTaxSubTotalRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTaxSubTotalRequestValidationError) ErrorName() string {
	return "CreateTaxSubTotalRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTaxSubTotalRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTaxSubTotalRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTaxSubTotalRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTaxSubTotalRequestValidationError{}

// Validate checks the field values on CreateTaxSubTotalResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTaxSubTotalResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTaxSubTotalResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTaxSubTotalResponseMultiError, or nil if none found.
func (m *CreateTaxSubTotalResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTaxSubTotalResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTaxSubTotal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTaxSubTotalResponseValidationError{
					field:  "TaxSubTotal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTaxSubTotalResponseValidationError{
					field:  "TaxSubTotal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTaxSubTotal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTaxSubTotalResponseValidationError{
				field:  "TaxSubTotal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTaxSubTotalResponseMultiError(errors)
	}

	return nil
}

// CreateTaxSubTotalResponseMultiError is an error wrapping multiple validation
// errors returned by CreateTaxSubTotalResponse.ValidateAll() if the
// designated constraints aren't met.
type CreateTaxSubTotalResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTaxSubTotalResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTaxSubTotalResponseMultiError) AllErrors() []error { return m }

// CreateTaxSubTotalResponseValidationError is the validation error returned by
// CreateTaxSubTotalResponse.Validate if the designated constraints aren't met.
type CreateTaxSubTotalResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTaxSubTotalResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTaxSubTotalResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTaxSubTotalResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTaxSubTotalResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTaxSubTotalResponseValidationError) ErrorName() string {
	return "CreateTaxSubTotalResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTaxSubTotalResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTaxSubTotalResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTaxSubTotalResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTaxSubTotalResponseValidationError{}

// Validate checks the field values on UpdateTaxSubTotalRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateTaxSubTotalRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateTaxSubTotalRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateTaxSubTotalRequestMultiError, or nil if none found.
func (m *UpdateTaxSubTotalRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateTaxSubTotalRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TaxableAmount

	// no validation rules for TaxAmount

	// no validation rules for CalculationSequenceNumeric

	// no validation rules for TransactionCurrencyTaxAmount

	// no validation rules for Percent

	// no validation rules for BaseUnitMeasure

	// no validation rules for PerUnitAmount

	// no validation rules for Id

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return UpdateTaxSubTotalRequestMultiError(errors)
	}

	return nil
}

// UpdateTaxSubTotalRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateTaxSubTotalRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateTaxSubTotalRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateTaxSubTotalRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateTaxSubTotalRequestMultiError) AllErrors() []error { return m }

// UpdateTaxSubTotalRequestValidationError is the validation error returned by
// UpdateTaxSubTotalRequest.Validate if the designated constraints aren't met.
type UpdateTaxSubTotalRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTaxSubTotalRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTaxSubTotalRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTaxSubTotalRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTaxSubTotalRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTaxSubTotalRequestValidationError) ErrorName() string {
	return "UpdateTaxSubTotalRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTaxSubTotalRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTaxSubTotalRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTaxSubTotalRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTaxSubTotalRequestValidationError{}

// Validate checks the field values on UpdateTaxSubTotalResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateTaxSubTotalResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateTaxSubTotalResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateTaxSubTotalResponseMultiError, or nil if none found.
func (m *UpdateTaxSubTotalResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateTaxSubTotalResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateTaxSubTotalResponseMultiError(errors)
	}

	return nil
}

// UpdateTaxSubTotalResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateTaxSubTotalResponse.ValidateAll() if the
// designated constraints aren't met.
type UpdateTaxSubTotalResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateTaxSubTotalResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateTaxSubTotalResponseMultiError) AllErrors() []error { return m }

// UpdateTaxSubTotalResponseValidationError is the validation error returned by
// UpdateTaxSubTotalResponse.Validate if the designated constraints aren't met.
type UpdateTaxSubTotalResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTaxSubTotalResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTaxSubTotalResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTaxSubTotalResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTaxSubTotalResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTaxSubTotalResponseValidationError) ErrorName() string {
	return "UpdateTaxSubTotalResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTaxSubTotalResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTaxSubTotalResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTaxSubTotalResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTaxSubTotalResponseValidationError{}

// Validate checks the field values on TaxTotal with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TaxTotal) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaxTotal with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TaxTotalMultiError, or nil
// if none found.
func (m *TaxTotal) ValidateAll() error {
	return m.validate(true)
}

func (m *TaxTotal) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTaxTotalD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaxTotalValidationError{
					field:  "TaxTotalD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaxTotalValidationError{
					field:  "TaxTotalD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTaxTotalD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaxTotalValidationError{
				field:  "TaxTotalD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaxTotalValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaxTotalValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaxTotalValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaxTotalValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaxTotalValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaxTotalValidationError{
				field:  "CrUpdTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TaxTotalMultiError(errors)
	}

	return nil
}

// TaxTotalMultiError is an error wrapping multiple validation errors returned
// by TaxTotal.ValidateAll() if the designated constraints aren't met.
type TaxTotalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaxTotalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaxTotalMultiError) AllErrors() []error { return m }

// TaxTotalValidationError is the validation error returned by
// TaxTotal.Validate if the designated constraints aren't met.
type TaxTotalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaxTotalValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaxTotalValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaxTotalValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaxTotalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaxTotalValidationError) ErrorName() string { return "TaxTotalValidationError" }

// Error satisfies the builtin error interface
func (e TaxTotalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaxTotal.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaxTotalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaxTotalValidationError{}

// Validate checks the field values on TaxTotalD with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TaxTotalD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaxTotalD with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TaxTotalDMultiError, or nil
// if none found.
func (m *TaxTotalD) ValidateAll() error {
	return m.validate(true)
}

func (m *TaxTotalD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for TaxAmount

	// no validation rules for RoundingAmount

	// no validation rules for TaxEvidenceIndicator

	// no validation rules for TaxIncludedIndicator

	// no validation rules for TaxCategoryId

	// no validation rules for MasterFlag

	// no validation rules for MasterId

	if len(errors) > 0 {
		return TaxTotalDMultiError(errors)
	}

	return nil
}

// TaxTotalDMultiError is an error wrapping multiple validation errors returned
// by TaxTotalD.ValidateAll() if the designated constraints aren't met.
type TaxTotalDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaxTotalDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaxTotalDMultiError) AllErrors() []error { return m }

// TaxTotalDValidationError is the validation error returned by
// TaxTotalD.Validate if the designated constraints aren't met.
type TaxTotalDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaxTotalDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaxTotalDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaxTotalDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaxTotalDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaxTotalDValidationError) ErrorName() string { return "TaxTotalDValidationError" }

// Error satisfies the builtin error interface
func (e TaxTotalDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaxTotalD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaxTotalDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaxTotalDValidationError{}

// Validate checks the field values on CreateTaxTotalRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTaxTotalRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTaxTotalRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTaxTotalRequestMultiError, or nil if none found.
func (m *CreateTaxTotalRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTaxTotalRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TaxAmount

	// no validation rules for RoundingAmount

	// no validation rules for TaxEvidenceIndicator

	// no validation rules for TaxIncludedIndicator

	// no validation rules for MasterFlag

	// no validation rules for MasterId

	// no validation rules for TaxCategoryId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateTaxTotalRequestMultiError(errors)
	}

	return nil
}

// CreateTaxTotalRequestMultiError is an error wrapping multiple validation
// errors returned by CreateTaxTotalRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateTaxTotalRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTaxTotalRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTaxTotalRequestMultiError) AllErrors() []error { return m }

// CreateTaxTotalRequestValidationError is the validation error returned by
// CreateTaxTotalRequest.Validate if the designated constraints aren't met.
type CreateTaxTotalRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTaxTotalRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTaxTotalRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTaxTotalRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTaxTotalRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTaxTotalRequestValidationError) ErrorName() string {
	return "CreateTaxTotalRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTaxTotalRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTaxTotalRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTaxTotalRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTaxTotalRequestValidationError{}

// Validate checks the field values on CreateTaxTotalResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTaxTotalResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTaxTotalResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTaxTotalResponseMultiError, or nil if none found.
func (m *CreateTaxTotalResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTaxTotalResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTaxTotal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTaxTotalResponseValidationError{
					field:  "TaxTotal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTaxTotalResponseValidationError{
					field:  "TaxTotal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTaxTotal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTaxTotalResponseValidationError{
				field:  "TaxTotal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTaxTotalResponseMultiError(errors)
	}

	return nil
}

// CreateTaxTotalResponseMultiError is an error wrapping multiple validation
// errors returned by CreateTaxTotalResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateTaxTotalResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTaxTotalResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTaxTotalResponseMultiError) AllErrors() []error { return m }

// CreateTaxTotalResponseValidationError is the validation error returned by
// CreateTaxTotalResponse.Validate if the designated constraints aren't met.
type CreateTaxTotalResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTaxTotalResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTaxTotalResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTaxTotalResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTaxTotalResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTaxTotalResponseValidationError) ErrorName() string {
	return "CreateTaxTotalResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTaxTotalResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTaxTotalResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTaxTotalResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTaxTotalResponseValidationError{}

// Validate checks the field values on UpdateTaxTotalRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateTaxTotalRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateTaxTotalRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateTaxTotalRequestMultiError, or nil if none found.
func (m *UpdateTaxTotalRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateTaxTotalRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TaxAmount

	// no validation rules for RoundingAmount

	// no validation rules for Id

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return UpdateTaxTotalRequestMultiError(errors)
	}

	return nil
}

// UpdateTaxTotalRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateTaxTotalRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateTaxTotalRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateTaxTotalRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateTaxTotalRequestMultiError) AllErrors() []error { return m }

// UpdateTaxTotalRequestValidationError is the validation error returned by
// UpdateTaxTotalRequest.Validate if the designated constraints aren't met.
type UpdateTaxTotalRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTaxTotalRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTaxTotalRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTaxTotalRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTaxTotalRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTaxTotalRequestValidationError) ErrorName() string {
	return "UpdateTaxTotalRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTaxTotalRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTaxTotalRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTaxTotalRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTaxTotalRequestValidationError{}

// Validate checks the field values on UpdateTaxTotalResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateTaxTotalResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateTaxTotalResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateTaxTotalResponseMultiError, or nil if none found.
func (m *UpdateTaxTotalResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateTaxTotalResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateTaxTotalResponseMultiError(errors)
	}

	return nil
}

// UpdateTaxTotalResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateTaxTotalResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateTaxTotalResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateTaxTotalResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateTaxTotalResponseMultiError) AllErrors() []error { return m }

// UpdateTaxTotalResponseValidationError is the validation error returned by
// UpdateTaxTotalResponse.Validate if the designated constraints aren't met.
type UpdateTaxTotalResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTaxTotalResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTaxTotalResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTaxTotalResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTaxTotalResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTaxTotalResponseValidationError) ErrorName() string {
	return "UpdateTaxTotalResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTaxTotalResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTaxTotalResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTaxTotalResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTaxTotalResponseValidationError{}
